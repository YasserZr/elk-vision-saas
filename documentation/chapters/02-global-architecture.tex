\chapter{Global Architecture}

\section{System Overview}

ELK Vision SaaS implements a microservices-inspired architecture with clear separation of concerns between frontend, backend, data processing, and storage layers. The system is designed for high availability, scalability, and real-time performance.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{system_architecture_diagram.png}
    \caption{ELK Vision SaaS System Architecture Overview}
    \label{fig:architecture}
\end{figure}

\section{Architecture Layers}

\subsection{Presentation Layer}

The presentation layer consists of the Next.js frontend application responsible for:

\begin{itemize}
    \item Rendering the user interface with React components
    \item Managing client-side state and routing
    \item Establishing WebSocket connections for real-time updates
    \item Communicating with the backend via REST API
\end{itemize}

\subsection{API Layer}

The Django backend serves as the API layer, providing:

\begin{itemize}
    \item RESTful API endpoints using Django REST Framework
    \item WebSocket endpoints via Django Channels for real-time streaming
    \item Token-based authentication and authorization
    \item Request validation and business logic execution
\end{itemize}

\subsection{Data Processing Layer}

The ELK Stack forms the data processing layer:

\begin{itemize}
    \item \textbf{Logstash}: Ingests, transforms, and routes log data
    \item \textbf{Elasticsearch}: Indexes and stores logs for fast search
    \item \textbf{Kibana}: Provides advanced visualization capabilities
\end{itemize}

\subsection{Storage Layer}

Multiple databases serve different purposes:

\begin{itemize}
    \item \textbf{PostgreSQL}: Stores user accounts, sessions, and application metadata
    \item \textbf{MongoDB}: Stores log metadata and upload tracking
    \item \textbf{Redis}: Handles caching, message passing, and WebSocket channel layer
    \item \textbf{Elasticsearch}: Primary storage for indexed log data
\end{itemize}

\section{Data Flow}

\subsection{Log Ingestion Flow}

\begin{enumerate}
    \item Log sources send data to Logstash via TCP (port 5000), UDP (port 5000), HTTP (port 8080), or Beats (port 5044)
    \item Logstash parses and transforms the incoming data using its pipeline configuration
    \item Processed logs are sent to two destinations simultaneously:
    \begin{itemize}
        \item Elasticsearch for persistent storage and search indexing
        \item Redis Pub/Sub channel for real-time streaming
    \end{itemize}
    \item The Real-time Listener service subscribes to Redis and forwards logs to WebSocket consumers
    \item Connected frontend clients receive logs via WebSocket with sub-second latency
\end{enumerate}

\subsection{Search and Query Flow}

\begin{enumerate}
    \item User enters search query in the frontend interface
    \item Frontend sends API request to Django backend with search parameters
    \item Backend constructs Elasticsearch query using the Django Elasticsearch DSL
    \item Elasticsearch returns matching documents with relevance scoring
    \item Backend formats and returns results to frontend
    \item Frontend renders search results in the UI
\end{enumerate}

\section{Network Architecture}

The Docker Compose configuration defines four isolated networks:

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Network} & \textbf{Purpose} & \textbf{Connected Services} \\
        \hline
        frontend\_network & UI routing & Frontend, Nginx, Backend \\
        \hline
        backend\_network & API communication & Backend, Redis, Logstash \\
        \hline
        elk\_network & ELK Stack internal & Elasticsearch, Logstash, Kibana \\
        \hline
        database\_network & Database access & PostgreSQL, MongoDB, Redis \\
        \hline
    \end{tabular}
    \caption{Docker Network Segmentation}
    \label{tab:networks}
\end{table}

\section{Service Dependencies}

The following diagram illustrates service startup order and dependencies:

\begin{verbatim}
postgres ─────────────────┐
mongodb ──────────────────┼──> backend ──> frontend ──> nginx
redis ────────────────────┤       │
elasticsearch ─> logstash ┘       │
                                  └──> celery_worker ──> celery_beat
                                  └──> realtime_listener
                                  └──> flower (monitoring)
\end{verbatim}

Services wait for their dependencies to be healthy before starting, ensuring reliable system initialization.
